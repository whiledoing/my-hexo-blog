---
title: 《The Art of UNIX Programming》学习笔记
tags: [self,learn-note,unix]
toc: true
date: 2016-02-01 20:08:14
---

[《The Art of UNIX Programming》](http://book.douban.com/subject/5387401/)这本书确实是久仰已久，加之自己最近一直在看linux相关的书籍，所以就带着看了一下。

花了3个小时将书翻了一下，摘录一下比较好的内容。（其实本来是想着慢慢读的，但是读的时候发现，一来是很多东西自己在别的书中都有了解过（[The Pragmatic Programmer](http://book.douban.com/subject/1417047/), [Code Complete](http://book.douban.com/subject/1432042/)），二来是因为很多东西其实也相对比较旧的，也就没有细看了。）

<!--more-->

基本大多数最有价值的想法都在第一章（哲学）中进行了说明。

---

> UNIX的哲学是这样的：一个程序只做一件事，并做好，程序要能协作。程序要能处理文本流，因为这是最通用的接口。

确实是无所不在的**KISS**，UNIX的哲学在于，每次只做好一件事情，然后通过一个个小而正交的工具/API/程序进行组合来得到更加强大的功能（如同书中说的，UNIX负责提供机制，而策略是使用者决定的，Happy Hacking!）

> 花哨的算法在n很小时通常很慢，而n通常很小。花哨算法的常数复杂度很大。除非你确定n总是很大，否则不要用花哨的算法。
> 花哨算法比简单算法更容易出bug，更难实现。尽量使用简单的算法配合简单的数据结构
> 过早优化是万恶之源

还有一个「更狠」的描述：

> 拿不准就穷举。

核心意义就在于：**尽量的保持简单，不要过早的优化**，除非你知道确实需要优化，以及需要优化的地方。

> 经济原则：宁花机器一分，不花程序员一秒。

有时候优化的效果还跑不赢：1）加内存条 2）摩尔定律导致的性能提升。。。。。

> 计算机编程的本质就是控制复杂度。
> 为了取得程序一丁点的性能提升就大幅度增加技术的复杂性和晦涩性，这个买卖做不得——这不仅仅是因为复杂的代码更容易滋生bug，也因为它会使日后的阅读和维护工作更加艰难。
> 清晰原则：清晰胜于机巧。

还是KISS，清新，简洁，简单才是构架大型系统（或者是复杂度极高）系统应该遵循的__最高原则__。

所以总的说来，LINUX的哲学就是：

1. KISS
2. 提供机制，不提供策略。

就是因为这样子的哲学，才会让UNIX设计出统一的I/O系统模型，管道，和强大的IPC等各种机制吧。

---

但是更大的哲学应该是「和谐」，这个世界上没有绝对正确的设计标准，至少在软件开发领域是没有银弹的。

如这个[ppt](http://herpolhode.com/rob/ugly.pdf)所说，UNIX也有一些不好的地方。

比如说，提供小而精的工具套就一定比提供大而全的系统要好嘛？我觉得也不一定吧。提供太多的选择反而有时候反而会让用户搞不清楚到底使用什么？

而相反，提供一个「权威甚至唯一」的工具，或者是无脑式的「一路next」封装至少对于大多数用户的大多数应用而言就足够了，这也就是为什么
windows占据怎么多年应用市场的原因吧。毕竟并不是所有的人都非常乐意去「hacking」和「customizatin」。

所以总的说来，UNIX/LINUX的设计哲学对于一个**开发人员**是非常有参考和实践价值的。

然后，我也是一个坚定的KISS实践者。

最后，摘录下[ppt](http://herpolhode.com/rob/ugly.pdf)中的言论：

> Two Answers:
>1. What is the best thing about UNIX?
>A: The community.
>2. What is the worst thing about UNIX?
>A: That there are so many communities.


